<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="CSV &amp; Text files"><meta property="og:title" content="CSV &amp; Text files" />
<meta property="og:description" content="CSV &amp; Text files The workhorse function for reading text files (a.k.a. flat files) is read_csv(). See the cookbook for some advanced strategies.
Parsing options read_csv() accepts the following common arguments:
Basic filepath_or_buffervarious
Either a path to a file (a str&rdquo;), pathlib.Path&rdquo;), or py._path.local.LocalPath), URL (including http, ftp, and S3 locations), or any object with a read() method (such as an open file or StringIO&rdquo;)).
sepstr, defaults to &#39;,&#39; for read_csv(), \t for read_table()" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dragon-library.github.io/library/tutorials/docs/python/pandas/1_io/csv-and-text-file/" />

<title>CSV &amp; Text files | Tutorials</title>
<link rel="icon" href="/library/tutorials/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/library/tutorials/book.min.4df2780858f349c50826000dfc9cb938f8635f9100451ec16066d3a035500451.css" integrity="sha256-TfJ4CFjzScUIJgAN/Jy5OPhjX5EARR7BYGbToDVQBFE=">


<script defer src="/library/tutorials/en.search.min.344568a8dca8d8ff4f6dba515f5f3fc0bf2a11140f21aada219a1cdea5e0da36.js" integrity="sha256-NEVoqNyo2P9PbbpRX18/wL8qERQPIaraIZoc3qXg2jY="></script>
<!-- highlight -->
  <link rel="stylesheet" href="https://dragon-library.github.io/library/tutorials/plugins/highlight/hybrid.css">


<!-- match-height JS -->
<script src="https://dragon-library.github.io/library/tutorials/plugins/match-height/jquery.matchHeight-min.js"></script>

<!-- highlight -->
<script src="https://dragon-library.github.io/library/tutorials/plugins/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://dragon-library.github.io/library/tutorials/"><span>Tutorials</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    

  
  





 
  
    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/library/tutorials/docs/python/" >
      Python
  </a>


    

    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/library/tutorials/docs/python/beginer/" >
      Beginners
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/library/tutorials/docs/python/pandas/" >
      Pandas
  </a>


    

    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/library/tutorials/docs/python/pandas/1_io/" >
      IO tools (text, CSV, HDF5, …)
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/library/tutorials/docs/python/pandas/1_io/csv-and-text-file/"  class="active">
      CSV &amp; Text files
  </a>

</li>
      
    
      
        <li>

  <a href="/library/tutorials/docs/python/pandas/1_io/html/" >
      HTML
  </a>

</li>
      
    
      
        <li>

  <a href="/library/tutorials/docs/python/pandas/1_io/excel/" >
      Excel files
  </a>

</li>
      
    
      
        <li>

  <a href="/library/tutorials/docs/python/pandas/1_io/clipboard/" >
      Clipboard
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
  </ul>
  



  </li>


      
    
      
        <li>

  <a href="/library/tutorials/docs/python/pythonthailand/" >
      Python Thailand
  </a>

</li>
      
    
      
        <li>

  <a href="/library/tutorials/docs/python/awesome/" >
      Awesome Python
  </a>

</li>
      
    
      
        

  <li >
    
      

  <a href="/library/tutorials/docs/python/e-book/" >
      e-Book
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/library/tutorials/docs/python/flask/" >
      Flask
  </a>


    

    






  </li>


      
    
      
        <li>

  <a href="/library/tutorials/docs/python/cheat-sheet/" >
      Python Cheat sheet
  </a>

</li>
      
    
      
        <li>

  <a href="/library/tutorials/docs/python/list-python-basics/" >
      List for Tutorial
  </a>

</li>
      
    
      
        <li>

  <a href="/library/tutorials/docs/python/modules-list/" >
      Modules List
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/library/tutorials/docs/front-end/bootstrap/basic-bootstap/" >
      Bootstrap 4 แบบพื้นฐาน
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/library/tutorials/docs/front-end/javascript/" >
      JavaScript
  </a>


    

    






  </li>


      
    
      
        

  <li >
    
      

  <a href="/library/tutorials/docs/articles/" >
      Articles
  </a>


    

    






  </li>


      
    
  </ul>
  



  











</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/library/tutorials/svg/menu.svg" alt="Menu" />
  </label>
  <strong>CSV &amp; Text files</strong>
</header>

      
<article class="markdown">

<h1 id="csv-text-files-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-csv-text-files-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#csv-text-files" title="Permalink to this headline">CSV &amp; Text files</a></h1>

<p>The workhorse function for reading text files (a.k.a. flat files) is  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a>. See the  <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/cookbook.html#cookbook-csv">cookbook</a>  for some advanced strategies.</p>

<h3 id="parsing-options-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-parsing-options-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#parsing-options" title="Permalink to this headline">Parsing options</a></h3>

<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a>  accepts the following common arguments:</p>

<h4 id="basic-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-basic-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#basic" title="Permalink to this headline">Basic</a></h4>

<p>filepath_or_buffervarious</p>

<p>Either a path to a file (a  <a href="https://docs.python.org/3/library/stdtypes.html#str &quot;(in Python v3.8"><code>str</code></a>&rdquo;),  <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path &quot;(in Python v3.8"><code>pathlib.Path</code></a>&rdquo;), or  <code>py._path.local.LocalPath</code>), URL (including http, ftp, and S3 locations), or any object with a  <code>read()</code>  method (such as an open file or  <a href="https://docs.python.org/3/library/io.html#io.StringIO &quot;(in Python v3.8"><code>StringIO</code></a>&rdquo;)).</p>

<p>sepstr, defaults to  <code>','</code>  for  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a>,  <code>\t</code>  for  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_table.html#pandas.read_table" title="pandas.read_table"><code>read_table()</code></a></p>

<p>Delimiter to use. If sep is  <code>None</code>, the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator by Python’s builtin sniffer tool,  <a href="https://docs.python.org/3/library/csv.html#csv.Sniffer &quot;(in Python v3.8"><code>csv.Sniffer</code></a>&rdquo;). In addition, separators longer than 1 character and different from  <code>'\s+'</code>  will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example:  <code>'\\r\\t'</code>.</p>

<p><strong>delimiterstr, default</strong>  <code>None</code>
Alternative argument name for sep.</p>

<p><strong>delim_whitespaceboolean, default False</strong>
Specifies whether or not whitespace (e.g.  <code>'  '</code>  or  <code>'\t'</code>) will be used as the delimiter. Equivalent to setting  <code>sep='\s+'</code>. If this option is set to  <code>True</code>, nothing should be passed in for the  <code>delimiter</code>  parameter.</p>

<h4 id="column-and-index-locations-and-names-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-column-and-index-locations-and-names-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#column-and-index-locations-and-names" title="Permalink to this headline">Column and index locations and names</a></h4>

<p><strong>headerint or list of ints, default</strong>  <code>'infer'</code>
Row number(s) to use as the column names, and the start of the data. Default behavior is to infer the column names: if no names are passed the behavior is identical to  <code>header=0</code>  and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to  <code>header=None</code>. Explicitly pass  <code>header=0</code>  to be able to replace existing names.</p>

<p>The header can be a list of ints that specify row locations for a MultiIndex on the columns e.g.  <code>[0,1,3]</code>. Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if  <code>skip_blank_lines=True</code>, so header=0 denotes the first line of data rather than the first line of the file.</p>

<p><strong>namesarray-like, default</strong>  <code>None</code>
List of column names to use. If file contains no header row, then you should explicitly pass  <code>header=None</code>. Duplicates in this list are not allowed.</p>

<p><strong>index_colint, str, sequence of int / str, or False, default</strong> <code>None</code>
Column(s) to use as the row labels of the  <code>DataFrame</code>, either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used.</p>

<p>Note:  <code>index_col=False</code>  can be used to force pandas to  <em>not</em>  use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line.</p>

<p>usecolslist-like or callable, default  <code>None</code></p>

<p>Return a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in  names  or inferred from the document header row(s). For example, a valid list-like  usecols  parameter would be  <code>[0,  1,  2]</code>  or  <code>['foo',  'bar',  'baz']</code>.</p>

<p>Element order is ignored, so  <code>usecols=[0,  1]</code>  is the same as  <code>[1,  0]</code>. To instantiate a DataFrame from  <code>data</code>  with element order preserved use  <code>pd.read_csv(data,  usecols=['foo',  'bar'])[['foo',  'bar']]</code>  for columns in  <code>['foo',  'bar']</code>  order or  <code>pd.read_csv(data,  usecols=['foo',  'bar'])[['bar',  'foo']]</code>  for  <code>['bar',  'foo']</code>  order.</p>

<p>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True:</p>

<pre><code class="language-py">In [1]: import pandas as pd

In [2]: from io import StringIO

In [3]: data = ('col1,col2,col3\n'
 ...:        'a,b,1\n'
 ...:        'a,b,2\n'
 ...:        'c,d,3')
 ...: 

In [4]: pd.read_csv(StringIO(data))
Out[4]: 
 col1 col2  col3
0    a    b     1
1    a    b     2
2    c    d     3

In [5]: pd.read_csv(StringIO(data), usecols=lambda x: x.upper() in ['COL1', 'COL3'])
Out[5]: 
 col1  col3
0    a     1
1    a     2
2    c     3
</code></pre>

<p>Using this parameter results in much faster parsing time and lower memory usage.</p>

<p><strong>squeezeboolean, default</strong>  <code>False</code>
If the parsed data only contains one column then return a  <code>Series</code>.</p>

<p><strong>prefixstr, default</strong>  <code>None</code>
Prefix to add to column numbers when no header, e.g. ‘X’ for X0, X1, …</p>

<p><strong>mangle_dupe_colsboolean, default</strong>  <code>True</code>
Duplicate columns will be specified as ‘X’, ‘X.1’…’X.N’, rather than ‘X’…’X’. Passing in  <code>False</code>  will cause data to be overwritten if there are duplicate names in the columns.</p>

<h4 id="general-parsing-configuration-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-general-parsing-configuration-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#general-parsing-configuration" title="Permalink to this headline">General parsing configuration</a></h4>

<p>dtypeType name or dict of column -&gt; type, default  <code>None</code></p>

<p>Data type for data or columns. E.g.  <code>{'a':  np.float64,  'b':  np.int32}</code>  (unsupported with  <code>engine='python'</code>). Use  str  or  object  together with suitable  <code>na_values</code>  settings to preserve and not interpret dtype.</p>

<p>engine{<code>'c'</code>,  <code>'python'</code>}</p>

<p>Parser engine to use. The C engine is faster while the Python engine is currently more feature-complete.</p>

<p>convertersdict, default  <code>None</code></p>

<p>Dict of functions for converting values in certain columns. Keys can either be integers or column labels.</p>

<p><strong>true_valueslist, default</strong>  <code>None</code>
<strong>Values to consider as</strong>  <code>True</code>.
<strong>false_valueslist, default</strong>  <code>None</code>
<strong>Values to consider as</strong>  <code>False</code>.
<strong>skipinitialspaceboolean, default</strong>  <code>False</code>
<strong>Skip spaces after delimiter.
skiprowslist-like or integer, default</strong>  <code>None</code></p>

<p>Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file.</p>

<p>If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise:</p>

<pre><code class="language-py">In [6]: data = ('col1,col2,col3\n'
 ...:        'a,b,1\n'
 ...:        'a,b,2\n'
 ...:        'c,d,3')
 ...: 

In [7]: pd.read_csv(StringIO(data))
Out[7]: 
 col1 col2  col3
0    a    b     1
1    a    b     2
2    c    d     3

In [8]: pd.read_csv(StringIO(data), skiprows=lambda x: x % 2 != 0)
Out[8]: 
 col1 col2  col3
0    a    b     2
</code></pre>

<p><strong>skipfooterint, default</strong>  <code>0</code>
Number of lines at bottom of file to skip (unsupported with engine=’c’).</p>

<p><strong>nrowsint, default</strong>  <code>None</code>
Number of rows of file to read. Useful for reading pieces of large files.</p>

<p><strong>low_memoryboolean, default</strong>  <code>True</code>
Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set  <code>False</code>, or specify the type with the  <code>dtype</code>  parameter. Note that the entire file is read into a single  <code>DataFrame</code>  regardless, use the  <code>chunksize</code>  or  <code>iterator</code>  parameter to return the data in chunks. (Only valid with C parser)</p>

<p><strong>memory_mapboolean, default False</strong>
If a filepath is provided for  <code>filepath_or_buffer</code>, map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead.</p>

<h4 id="na-and-missing-data-handling-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-na-and-missing-data-handling-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#na-and-missing-data-handling" title="Permalink to this headline">NA and missing data handling</a></h4>

<p><strong>na_valuesscalar, str, list-like, or dict, default</strong>  <code>None</code>
Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. See  <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-navaluesconst">na values const</a>  below for a list of the values interpreted as NaN by default.</p>

<p><strong>keep_default_naboolean, default</strong>  <code>True</code>
Whether or not to include the default NaN values when parsing the data. Depending on whether  na_values  is passed in, the behavior is as follows:</p>

<ul>
<li><p>If  keep_default_na  is  <code>True</code>, and  na_values  are specified,  na_values  is appended to the default NaN values used for parsing.</p></li>

<li><p>If  keep_default_na  is  <code>True</code>, and  na_values  are not specified, only the default NaN values are used for parsing.</p></li>

<li><p>If  keep_default_na  is  <code>False</code>, and  na_values  are specified, only the NaN values specified  na_values  are used for parsing.</p></li>

<li><p>If  keep_default_na  is  <code>False</code>, and  na_values  are not specified, no strings will be parsed as NaN.</p></li>
</ul>

<p>Note that if  na_filter  is passed in as  <code>False</code>, the  keep_default_na  and  na_values  parameters will be ignored.</p>

<p>na_filterboolean, default  <code>True</code></p>

<p>Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing  <code>na_filter=False</code>  can improve the performance of reading a large file.</p>

<p>verboseboolean, default  <code>False</code></p>

<p>Indicate number of NA values placed in non-numeric columns.</p>

<p>skip_blank_linesboolean, default  <code>True</code></p>

<p>If  <code>True</code>, skip over blank lines rather than interpreting as NaN values.</p>

<h4 id="datetime-handling-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-datetime-handling-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#datetime-handling" title="Permalink to this headline">Datetime handling</a></h4>

<p>parse_datesboolean or list of ints or names or list of lists or dict, default  <code>False</code>.</p>

<ul>
<li><p>If  <code>True</code>  -&gt; try parsing the index.</p></li>

<li><p>If  <code>[1,  2,  3]</code>  -&gt; try parsing columns 1, 2, 3 each as a separate date column.</p></li>

<li><p>If  <code>[[1,  3]]</code>  -&gt; combine columns 1 and 3 and parse as a single date column.</p></li>

<li><p>If  <code>{'foo':  [1,  3]}</code>  -&gt; parse columns 1, 3 as date and call result ‘foo’. A fast-path exists for iso8601-formatted dates.</p></li>
</ul>

<p>infer_datetime_formatboolean, default  <code>False</code></p>

<p>If  <code>True</code>  and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing.</p>

<p>keep_date_colboolean, default  <code>False</code></p>

<p>If  <code>True</code>  and parse_dates specifies combining multiple columns then keep the original columns.</p>

<p>date_parserfunction, default  <code>None</code></p>

<p>Function to use for converting a sequence of string columns to an array of datetime instances. The default uses  <code>dateutil.parser.parser</code>  to do the conversion. pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments.</p>

<p>dayfirstboolean, default  <code>False</code></p>

<p>DD/MM format dates, international and European format.</p>

<p>cache_datesboolean, default True</p>

<p>If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets.</p>

<p>New in version 0.25.0.</p>

<h4 id="iteration-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-iteration-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#iteration" title="Permalink to this headline">Iteration</a></h4>

<p>iteratorboolean, default  <code>False</code></p>

<p>Return  TextFileReader  object for iteration or getting chunks with  <code>get_chunk()</code>.</p>

<p>chunksizeint, default  <code>None</code></p>

<p>Return  TextFileReader  object for iteration. See  <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-chunking">iterating and chunking</a>  below.</p>

<h4 id="quoting-compression-and-file-format-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-quoting-compression-and-file-format-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#quoting-compression-and-file-format" title="Permalink to this headline">Quoting, compression, and file format</a></h4>

<pre><code class="language-py">compression{`'infer'`,  `'gzip'`,  `'bz2'`,  `'zip'`,  `'xz'`,  `None`}, default  `'infer'`
</code></pre>

<p>For on-the-fly decompression of on-disk data. If ‘infer’, then use gzip, bz2, zip, or xz if filepath_or_buffer is a string ending in ‘.gz’, ‘.bz2’, ‘.zip’, or ‘.xz’, respectively, and no decompression otherwise. If using ‘zip’, the ZIP file must contain only one data file to be read in. Set to  <code>None</code>  for no decompression.</p>

<p>Changed in version 0.24.0: ‘infer’ option added and set to default.</p>

<p>thousandsstr, default  <code>None</code></p>

<p>Thousands separator.</p>

<p>decimalstr, default  <code>'.'</code></p>

<p>Character to recognize as decimal point. E.g. use  <code>','</code>  for European data.</p>

<p>float_precisionstring, default None</p>

<p>Specifies which converter the C engine should use for floating-point values. The options are  <code>None</code>  for the ordinary converter,  <code>high</code>  for the high-precision converter, and  <code>round_trip</code>  for the round-trip converter.</p>

<p><strong>lineterminatorstr (length 1), default</strong>  <code>None</code>
Character to break file into lines. Only valid with C parser.</p>

<p><strong>quotecharstr (length 1)</strong>
The character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored.</p>

<p>quotingint or  <code>csv.QUOTE_*</code>  instance, default  <code>0</code></p>

<p>Control field quoting behavior per  <code>csv.QUOTE_*</code>  constants. Use one of  <code>QUOTE_MINIMAL</code>  (0),  <code>QUOTE_ALL</code>  (1),  <code>QUOTE_NONNUMERIC</code>  (2) or  <code>QUOTE_NONE</code>  (3).</p>

<p>doublequoteboolean, default  <code>True</code></p>

<p>When  <code>quotechar</code>  is specified and  <code>quoting</code>  is not  <code>QUOTE_NONE</code>, indicate whether or not to interpret two consecutive  <code>quotechar</code>  elements  <strong>inside</strong>  a field as a single  <code>quotechar</code>  element.</p>

<p>escapecharstr (length 1), default  <code>None</code></p>

<p>One-character string used to escape delimiter when quoting is  <code>QUOTE_NONE</code>.</p>

<p>commentstr, default  <code>None</code></p>

<p>Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as  <code>skip_blank_lines=True</code>), fully commented lines are ignored by the parameter  header  but not by  skiprows. For example, if  <code>comment='#'</code>, parsing ‘#empty\na,b,c\n1,2,3’ with  header=0  will result in ‘a,b,c’ being treated as the header.</p>

<p>encodingstr, default  <code>None</code></p>

<p>Encoding to use for UTF when reading/writing (e.g.  <code>'utf-8'</code>).  <a href="https://docs.python.org/3/library/codecs.html#standard-encodings">List of Python standard encodings</a>.</p>

<p>dialectstr or  <a href="https://docs.python.org/3/library/csv.html#csv.Dialect &quot;(in Python v3.8"><code>csv.Dialect</code></a>&rdquo;)  instance, default  <code>None</code></p>

<p>If provided, this parameter will override values (default or not) for the following parameters:  delimiter,  doublequote,  escapechar,  skipinitialspace,  quotechar, and  quoting. If it is necessary to override values, a ParserWarning will be issued. See  <a href="https://docs.python.org/3/library/csv.html#csv.Dialect &quot;(in Python v3.8"><code>csv.Dialect</code></a>&rdquo;)  documentation for more details.</p>

<h4 id="error-handling-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-error-handling-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#error-handling" title="Permalink to this headline">Error handling</a></h4>

<p>error_bad_linesboolean, default  <code>True</code></p>

<p>Lines with too many fields (e.g. a csv line with too many commas) will by default cause an exception to be raised, and no  <code>DataFrame</code>  will be returned. If  <code>False</code>, then these “bad lines” will dropped from the  <code>DataFrame</code>  that is returned. See  <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-bad-lines">bad lines</a>  below.</p>

<p>warn_bad_linesboolean, default  <code>True</code></p>

<p>If error_bad_lines is  <code>False</code>, and warn_bad_lines is  <code>True</code>, a warning for each “bad line” will be output.</p>

<h3 id="specifying-column-data-types-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-specifying-column-data-types-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#specifying-column-data-types" title="Permalink to this headline">Specifying column data types</a></h3>

<p>You can indicate the data type for the whole  <code>DataFrame</code>  or individual columns:</p>

<pre><code class="language-py">In [9]: import numpy as np

In [10]: data = ('a,b,c,d\n'
 ....:        '1,2,3,4\n'
 ....:        '5,6,7,8\n'
 ....:        '9,10,11')
 ....: 

In [11]: print(data)
a,b,c,d
1,2,3,4
5,6,7,8
9,10,11

In [12]: df = pd.read_csv(StringIO(data), dtype=object)

In [13]: df
Out[13]: 
 a   b   c    d
0  1   2   3    4
1  5   6   7    8
2  9  10  11  NaN

In [14]: df['a'][0]
Out[14]: '1'

In [15]: df = pd.read_csv(StringIO(data),
 ....:                 dtype={'b': object, 'c': np.float64, 'd': 'Int64'})
 ....: 

In [16]: df.dtypes
Out[16]: 
a      int64
b     object
c    float64
d      Int64
dtype: object
</code></pre>

<p>Fortunately, pandas offers more than one way to ensure that your column(s) contain only one  <code>dtype</code>. If you’re unfamiliar with these concepts, you can see  <a href="https://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html#basics-dtypes">here</a>  to learn more about dtypes, and  <a href="https://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html#basics-object-conversion">here</a>  to learn more about  <code>object</code>  conversion in pandas.</p>

<p>For instance, you can use the  <code>converters</code>  argument of  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a>:</p>

<pre><code class="language-py">In [17]: data = (&quot;col_1\n&quot;
 ....:        &quot;1\n&quot;
 ....:        &quot;2\n&quot;
 ....:        &quot;'A'\n&quot;
 ....:        &quot;4.22&quot;)
 ....: 

In [18]: df = pd.read_csv(StringIO(data), converters={'col_1': str})

In [19]: df
Out[19]: 
 col_1
0     1
1     2
2   'A'
3  4.22

In [20]: df['col_1'].apply(type).value_counts()
Out[20]: 
&lt;class 'str'&gt;    4
Name: col_1, dtype: int64
</code></pre>

<p>Or you can use the  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_numeric.html#pandas.to_numeric" title="pandas.to_numeric"><code>to_numeric()</code></a>  function to coerce the dtypes after reading in the data,</p>

<pre><code class="language-py">In [21]: df2 = pd.read_csv(StringIO(data))

In [22]: df2['col_1'] = pd.to_numeric(df2['col_1'], errors='coerce')

In [23]: df2
Out[23]: 
 col_1
0   1.00
1   2.00
2    NaN
3   4.22

In [24]: df2['col_1'].apply(type).value_counts()
Out[24]: 
&lt;class 'float'&gt;    4
Name: col_1, dtype: int64
</code></pre>

<p>which will convert all valid parsing to floats, leaving the invalid parsing as  <code>NaN</code>.</p>

<p>Ultimately, how you deal with reading in columns containing mixed dtypes depends on your specific needs. In the case above, if you wanted to  <code>NaN</code>  out the data anomalies, then  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_numeric.html#pandas.to_numeric" title="pandas.to_numeric"><code>to_numeric()</code></a>  is probably your best option. However, if you wanted for all the data to be coerced, no matter the type, then using the  <code>converters</code>  argument of  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a>  would certainly be worth trying.</p>

<blockquote>
<p>Note</p>

<p>In some cases, reading in abnormal data with columns containing mixed dtypes will result in an inconsistent dataset. If you rely on pandas to infer the dtypes of your columns, the parsing engine will go and infer the dtypes for different chunks of the data, rather than the whole dataset at once. Consequently, you can end up with column(s) with mixed dtypes. For example,</p>
</blockquote>

<pre><code class="language-py">In [25]: col_1 = list(range(500000)) + ['a', 'b'] + list(range(500000))

In [26]: df = pd.DataFrame({'col_1': col_1})

In [27]: df.to_csv('foo.csv')

In [28]: mixed_df = pd.read_csv('foo.csv')

In [29]: mixed_df['col_1'].apply(type).value_counts()
Out[29]: 
&lt;class 'int'&gt;    737858
&lt;class 'str'&gt;    262144
Name: col_1, dtype: int64

In [30]: mixed_df['col_1'].dtype
Out[30]: dtype('O')
</code></pre>

<p>will result with  mixed_df  containing an  <code>int</code>  dtype for certain chunks of the column, and  <code>str</code>  for others due to the mixed dtypes from the data that was read in. It is important to note that the overall column will be marked with a  <code>dtype</code>  of  <code>object</code>, which is used for columns with mixed dtypes.</p>

<h3 id="specifying-categorical-dtype-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-specifying-categorical-dtype-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#specifying-categorical-dtype" title="Permalink to this headline">Specifying categorical dtype</a></h3>

<p><code>Categorical</code>  columns can be parsed directly by specifying  <code>dtype='category'</code>  or  <code>dtype=CategoricalDtype(categories,  ordered)</code>.</p>

<pre><code class="language-py">In [31]: data = ('col1,col2,col3\n'
 ....:        'a,b,1\n'
 ....:        'a,b,2\n'
 ....:        'c,d,3')
 ....: 

In [32]: pd.read_csv(StringIO(data))
Out[32]: 
 col1 col2  col3
0    a    b     1
1    a    b     2
2    c    d     3

In [33]: pd.read_csv(StringIO(data)).dtypes
Out[33]: 
col1    object
col2    object
col3     int64
dtype: object

In [34]: pd.read_csv(StringIO(data), dtype='category').dtypes
Out[34]: 
col1    category
col2    category
col3    category
dtype: object

Individual columns can be parsed as a  `Categorical`  using a dict specification:

In [35]: pd.read_csv(StringIO(data), dtype={'col1': 'category'}).dtypes
Out[35]: 
col1    category
col2      object
col3       int64
dtype: object

New in version 0.21.0.

Specifying  `dtype='category'`  will result in an unordered  `Categorical`  whose  `categories`  are the unique values observed in the data. For more control on the categories and order, create a  `CategoricalDtype`  ahead of time, and pass that for that column’s  `dtype`.

In [36]: from pandas.api.types import CategoricalDtype

In [37]: dtype = CategoricalDtype(['d', 'c', 'b', 'a'], ordered=True)

In [38]: pd.read_csv(StringIO(data), dtype={'col1': dtype}).dtypes
Out[38]: 
col1    category
col2      object
col3       int64
dtype: object
</code></pre>

<p>When using  <code>dtype=CategoricalDtype</code>, “unexpected” values outside of  <code>dtype.categories</code>  are treated as missing values.</p>

<pre><code class="language-py">In [39]: dtype = CategoricalDtype(['a', 'b', 'd'])  # No 'c'

In [40]: pd.read_csv(StringIO(data), dtype={'col1': dtype}).col1
Out[40]: 
0      a
1      a
2    NaN
Name: col1, dtype: category
Categories (3, object): [a, b, d]
</code></pre>

<p>This matches the behavior of  <code>Categorical.set_categories()</code>.</p>

<p>Note</p>

<p>With  <code>dtype='category'</code>, the resulting categories will always be parsed as strings (object dtype). If the categories are numeric they can be converted using the  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_numeric.html#pandas.to_numeric" title="pandas.to_numeric"><code>to_numeric()</code></a>  function, or as appropriate, another converter such as  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html#pandas.to_datetime" title="pandas.to_datetime"><code>to_datetime()</code></a>.</p>

<p>When  <code>dtype</code>  is a  <code>CategoricalDtype</code>  with homogeneous  <code>categories</code>  ( all numeric, all datetimes, etc.), the conversion is done automatically.</p>

<pre><code class="language-py">In [41]: df = pd.read_csv(StringIO(data), dtype='category')

In [42]: df.dtypes
Out[42]: 
col1    category
col2    category
col3    category
dtype: object

In [43]: df['col3']
Out[43]: 
0    1
1    2
2    3
Name: col3, dtype: category
Categories (3, object): [1, 2, 3]

In [44]: df['col3'].cat.categories = pd.to_numeric(df['col3'].cat.categories)

In [45]: df['col3']
Out[45]: 
0    1
1    2
2    3
Name: col3, dtype: category
Categories (3, int64): [1, 2, 3]
</code></pre>

<h3 id="naming-and-using-columns-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-naming-and-using-columns-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#naming-and-using-columns" title="Permalink to this headline">Naming and using columns</a></h3>

<h4 id="handling-column-names-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-handling-column-names-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#handling-column-names" title="Permalink to this headline">Handling column names</a></h4>

<p>A file may or may not have a header row. pandas assumes the first row should be used as the column names:</p>

<pre><code class="language-py">In [46]: data = ('a,b,c\n'
 ....:        '1,2,3\n'
 ....:        '4,5,6\n'
 ....:        '7,8,9')
 ....: 

In [47]: print(data)
a,b,c
1,2,3
4,5,6
7,8,9

In [48]: pd.read_csv(StringIO(data))
Out[48]: 
 a  b  c
0  1  2  3
1  4  5  6
2  7  8  9
</code></pre>

<p>By specifying the  <code>names</code>  argument in conjunction with  <code>header</code>  you can indicate other names to use and whether or not to throw away the header row (if any):</p>

<pre><code class="language-py">In [49]: print(data)
a,b,c
1,2,3
4,5,6
7,8,9

In [50]: pd.read_csv(StringIO(data), names=['foo', 'bar', 'baz'], header=0)
Out[50]: 
 foo  bar  baz
0    1    2    3
1    4    5    6
2    7    8    9

In [51]: pd.read_csv(StringIO(data), names=['foo', 'bar', 'baz'], header=None)
Out[51]: 
 foo bar baz
0   a   b   c
1   1   2   3
2   4   5   6
3   7   8   9
</code></pre>

<p>If the header is in a row other than the first, pass the row number to  <code>header</code>. This will skip the preceding rows:</p>

<pre><code class="language-py">In [52]: data = ('skip this skip it\n'
 ....:        'a,b,c\n'
 ....:        '1,2,3\n'
 ....:        '4,5,6\n'
 ....:        '7,8,9')
 ....: 

In [53]: pd.read_csv(StringIO(data), header=1)
Out[53]: 
 a  b  c
0  1  2  3
1  4  5  6
2  7  8  9
</code></pre>

<blockquote>
<p>Note</p>

<p>Default behavior is to infer the column names: if no names are passed the behavior is identical to  <code>header=0</code>  and column names are inferred from the first non-blank line of the file, if column names are passed explicitly then the behavior is identical to  <code>header=None</code>.</p>
</blockquote>

<h3 id="duplicate-names-parsing-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-duplicate-names-parsing-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#duplicate-names-parsing" title="Permalink to this headline">Duplicate names parsing</a></h3>

<p>If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data:</p>

<pre><code class="language-py">In [54]: data = ('a,b,a\n'
 ....:        '0,1,2\n'
 ....:        '3,4,5')
 ....: 

In [55]: pd.read_csv(StringIO(data))
Out[55]: 
 a  b  a.1
0  0  1    2
1  3  4    5
</code></pre>

<p>There is no more duplicate data because  <code>mangle_dupe_cols=True</code>  by default, which modifies a series of duplicate columns ‘X’, …, ‘X’ to become ‘X’, ‘X.1’, …, ‘X.N’. If  <code>mangle_dupe_cols=False</code>, duplicate data can arise:</p>

<pre><code class="language-py">In [2]: data = 'a,b,a\n0,1,2\n3,4,5'
In [3]: pd.read_csv(StringIO(data), mangle_dupe_cols=False)
Out[3]:
 a  b  a
0  2  1  2
1  5  4  5
</code></pre>

<p>To prevent users from encountering this problem with duplicate data, a  <code>ValueError</code>  exception is raised if  <code>mangle_dupe_cols  !=  True</code>:</p>

<pre><code class="language-py">In [2]: data = 'a,b,a\n0,1,2\n3,4,5'
In [3]: pd.read_csv(StringIO(data), mangle_dupe_cols=False)
...
ValueError: Setting mangle_dupe_cols=False is not supported yet
</code></pre>

<h4 id="filtering-columns-usecols-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-filtering-columns-usecols-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#filtering-columns-usecols" title="Permalink to this headline">Filtering columns (<code>usecols</code>)</a></h4>

<p>The  <code>usecols</code>  argument allows you to select any subset of the columns in a file, either using the column names, position numbers or a callable:</p>

<pre><code class="language-py">In [56]: data = 'a,b,c,d\n1,2,3,foo\n4,5,6,bar\n7,8,9,baz'

In [57]: pd.read_csv(StringIO(data))
Out[57]: 
 a  b  c    d
0  1  2  3  foo
1  4  5  6  bar
2  7  8  9  baz

In [58]: pd.read_csv(StringIO(data), usecols=['b', 'd'])
Out[58]: 
 b    d
0  2  foo
1  5  bar
2  8  baz

In [59]: pd.read_csv(StringIO(data), usecols=[0, 2, 3])
Out[59]: 
 a  c    d
0  1  3  foo
1  4  6  bar
2  7  9  baz

In [60]: pd.read_csv(StringIO(data), usecols=lambda x: x.upper() in ['A', 'C'])
Out[60]: 
 a  c
0  1  3
1  4  6
2  7  9
</code></pre>

<p>The  <code>usecols</code>  argument can also be used to specify which columns not to use in the final result:</p>

<pre><code class="language-py">In [61]: pd.read_csv(StringIO(data), usecols=lambda x: x not in ['a', 'c'])
Out[61]: 
 b    d
0  2  foo
1  5  bar
2  8  baz
</code></pre>

<p>In this case, the callable is specifying that we exclude the “a” and “c” columns from the output.</p>

<h3 id="comments-and-empty-lines-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-comments-and-empty-lines-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#comments-and-empty-lines" title="Permalink to this headline">Comments and empty lines</a></h3>

<h4 id="ignoring-line-comments-and-empty-lines-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-ignoring-line-comments-and-empty-lines-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#ignoring-line-comments-and-empty-lines" title="Permalink to this headline">Ignoring line comments and empty lines</a></h4>

<p>If the  <code>comment</code>  parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well.</p>

<pre><code class="language-py">In [62]: data = ('\n'
 ....:        'a,b,c\n'
 ....:        ' \n'
 ....:        '# commented line\n'
 ....:        '1,2,3\n'
 ....:        '\n'
 ....:        '4,5,6')
 ....: 

In [63]: print(data)

a,b,c
  
# commented line
1,2,3

4,5,6

In [64]: pd.read_csv(StringIO(data), comment='#')
Out[64]: 
 a  b  c
0  1  2  3
1  4  5  6
</code></pre>

<p>If  <code>skip_blank_lines=False</code>, then  <code>read_csv</code>  will not ignore blank lines:</p>

<pre><code class="language-py">In [65]: data = ('a,b,c\n'
 ....:        '\n'
 ....:        '1,2,3\n'
 ....:        '\n'
 ....:        '\n'
 ....:        '4,5,6')
 ....: 

In [66]: pd.read_csv(StringIO(data), skip_blank_lines=False)
Out[66]: 
 a    b    c
0  NaN  NaN  NaN
1  1.0  2.0  3.0
2  NaN  NaN  NaN
3  NaN  NaN  NaN
4  4.0  5.0  6.0
</code></pre>

<blockquote>
<p>Warning</p>

<p>The presence of ignored lines might create ambiguities involving line numbers; the parameter  <code>header</code>  uses row &gt;numbers (ignoring commented/empty lines), while  <code>skiprows</code>  uses line numbers (including commented/empty lines):</p>
</blockquote>

<pre><code class="language-py">In [67]: data = ('#comment\n'
 ....:        'a,b,c\n'
 ....:        'A,B,C\n'
 ....:        '1,2,3')
 ....: 

In [68]: pd.read_csv(StringIO(data), comment='#', header=1)
Out[68]: 
 A  B  C
0  1  2  3

In [69]: data = ('A,B,C\n'
 ....:        '#comment\n'
 ....:        'a,b,c\n'
 ....:        '1,2,3')
 ....: 

In [70]: pd.read_csv(StringIO(data), comment='#', skiprows=2)
Out[70]: 
 a  b  c
0  1  2  3
</code></pre>

<p>If both  <code>header</code>  and  <code>skiprows</code>  are specified,  <code>header</code>  will be relative to the end of  <code>skiprows</code>. For example:</p>

<pre><code class="language-py">In [71]: data = ('# empty\n'
 ....:        '# second empty line\n'
 ....:        '# third emptyline\n'
 ....:        'X,Y,Z\n'
 ....:        '1,2,3\n'
 ....:        'A,B,C\n'
 ....:        '1,2.,4.\n'
 ....:        '5.,NaN,10.0\n')
 ....: 

In [72]: print(data)
# empty
# second empty line
# third emptyline
X,Y,Z
1,2,3
A,B,C
1,2.,4.
5.,NaN,10.0

In [73]: pd.read_csv(StringIO(data), comment='#', skiprows=4, header=1)
Out[73]: 
 A    B     C
0  1.0  2.0   4.0
1  5.0  NaN  10.0
</code></pre>

<h4 id="comments-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-comments-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#comments" title="Permalink to this headline">Comments</a></h4>

<p>Sometimes comments or meta data may be included in a file:</p>

<pre><code class="language-py">In [74]: print(open('tmp.csv').read())
ID,level,category
Patient1,123000,x # really unpleasant
Patient2,23000,y # wouldn't take his medicine
Patient3,1234018,z # awesome
</code></pre>

<p>By default, the parser includes the comments in the output:</p>

<pre><code class="language-py">In [75]: df = pd.read_csv('tmp.csv')

In [76]: df
Out[76]: 
 ID    level                        category
0  Patient1   123000           x # really unpleasant
1  Patient2    23000  y # wouldn't take his medicine
2  Patient3  1234018                     z # awesome
</code></pre>

<p>We can suppress the comments using the  <code>comment</code>  keyword:</p>

<pre><code class="language-py">In [77]: df = pd.read_csv('tmp.csv', comment='#')

In [78]: df
Out[78]: 
 ID    level category
0  Patient1   123000       x 
1  Patient2    23000       y 
2  Patient3  1234018       z 
</code></pre>

<h3 id="dealing-with-unicode-data-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-dealing-with-unicode-data-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#dealing-with-unicode-data" title="Permalink to this headline">Dealing with Unicode data</a></h3>

<p>The  <code>encoding</code>  argument should be used for encoded unicode data, which will result in byte strings being decoded to unicode in the result:</p>

<pre><code class="language-py">In [79]: from io import BytesIO

In [80]: data = (b'word,length\n'
 ....:        b'Tr\xc3\xa4umen,7\n'
 ....:        b'Gr\xc3\xbc\xc3\x9fe,5')
 ....: 

In [81]: data = data.decode('utf8').encode('latin-1')

In [82]: df = pd.read_csv(BytesIO(data), encoding='latin-1')

In [83]: df
Out[83]: 
 word  length
0  Träumen       7
1    Grüße       5

In [84]: df['word'][1]
Out[84]: 'Grüße'
</code></pre>

<p>Some formats which encode all characters as multiple bytes, like UTF-16, won’t parse correctly at all without specifying the encoding.  <a href="https://docs.python.org/3/library/codecs.html#standard-encodings">Full list of Python standard encodings</a>.</p>

<h3 id="index-columns-and-trailing-delimiters-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-index-columns-and-trailing-delimiters-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#index-columns-and-trailing-delimiters" title="Permalink to this headline">Index columns and trailing delimiters</a></h3>

<p>If a file has one more column of data than the number of column names, the first column will be used as the  <code>DataFrame</code>’s row names:</p>

<pre><code class="language-py">In [85]: data = ('a,b,c\n'
 ....:        '4,apple,bat,5.7\n'
 ....:        '8,orange,cow,10')
 ....: 

In [86]: pd.read_csv(StringIO(data))
Out[86]: 
 a    b     c
4   apple  bat   5.7
8  orange  cow  10.0

In [87]: data = ('index,a,b,c\n'
 ....:        '4,apple,bat,5.7\n'
 ....:        '8,orange,cow,10')
 ....: 

In [88]: pd.read_csv(StringIO(data), index_col=0)
Out[88]: 
 a    b     c
index 
4       apple  bat   5.7
8      orange  cow  10.0
</code></pre>

<p>Ordinarily, you can achieve this behavior using the  <code>index_col</code>  option.</p>

<p>There are some exception cases when a file has been prepared with delimiters at the end of each data line, confusing the parser. To explicitly disable the index column inference and discard the last column, pass  <code>index_col=False</code>:</p>

<pre><code class="language-py">In [89]: data = ('a,b,c\n'
 ....:        '4,apple,bat,\n'
 ....:        '8,orange,cow,')
 ....: 

In [90]: print(data)
a,b,c
4,apple,bat,
8,orange,cow,

In [91]: pd.read_csv(StringIO(data))
Out[91]: 
 a    b   c
4   apple  bat NaN
8  orange  cow NaN

In [92]: pd.read_csv(StringIO(data), index_col=False)
Out[92]: 
 a       b    c
0  4   apple  bat
1  8  orange  cow
</code></pre>

<p>If a subset of data is being parsed using the  <code>usecols</code>  option, the  <code>index_col</code>  specification is based on that subset, not the original data.</p>

<pre><code class="language-py">In [93]: data = ('a,b,c\n'
 ....:        '4,apple,bat,\n'
 ....:        '8,orange,cow,')
 ....: 

In [94]: print(data)
a,b,c
4,apple,bat,
8,orange,cow,

In [95]: pd.read_csv(StringIO(data), usecols=['b', 'c'])
Out[95]: 
 b   c
4  bat NaN
8  cow NaN

In [96]: pd.read_csv(StringIO(data), usecols=['b', 'c'], index_col=0)
Out[96]: 
 b   c
4  bat NaN
8  cow NaN
</code></pre>

<h3 id="date-handling-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-date-handling-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#date-handling" title="Permalink to this headline">Date Handling</a></h3>

<h4 id="specifying-date-columns-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-specifying-date-columns-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#specifying-date-columns" title="Permalink to this headline">Specifying date columns</a></h4>

<p>To better facilitate working with datetime data,  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a>  uses the keyword arguments  <code>parse_dates</code>  and  <code>date_parser</code>  to allow users to specify a variety of columns and date/time formats to turn the input text data into  <code>datetime</code>  objects.</p>

<p>The simplest case is to just pass in  <code>parse_dates=True</code>:</p>

<pre><code class="language-py"># Use a column as an index, and parse it as dates.
In [97]: df = pd.read_csv('foo.csv', index_col=0, parse_dates=True)

In [98]: df
Out[98]: 
 A  B  C
date 
2009-01-01  a  1  2
2009-01-02  b  3  4
2009-01-03  c  4  5

# These are Python datetime objects
In [99]: df.index
Out[99]: DatetimeIndex(['2009-01-01', '2009-01-02', '2009-01-03'], dtype='datetime64[ns]', name='date', freq=None)
</code></pre>

<p>It is often the case that we may want to store date and time data separately, or store various date fields separately. the  <code>parse_dates</code>  keyword can be used to specify a combination of columns to parse the dates and/or times from.</p>

<p>You can specify a list of column lists to  <code>parse_dates</code>, the resulting date columns will be prepended to the output (so as to not affect the existing column order) and the new column names will be the concatenation of the component column names:</p>

<pre><code class="language-py">In [100]: print(open('tmp.csv').read())
KORD,19990127, 19:00:00, 18:56:00, 0.8100
KORD,19990127, 20:00:00, 19:56:00, 0.0100
KORD,19990127, 21:00:00, 20:56:00, -0.5900
KORD,19990127, 21:00:00, 21:18:00, -0.9900
KORD,19990127, 22:00:00, 21:56:00, -0.5900
KORD,19990127, 23:00:00, 22:56:00, -0.5900

In [101]: df = pd.read_csv('tmp.csv', header=None, parse_dates=[[1, 2], [1, 3]])

In [102]: df
Out[102]: 
 1_2                 1_3     0     4
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</code></pre>

<p>By default the parser removes the component date columns, but you can choose to retain them via the  <code>keep_date_col</code>  keyword:</p>

<pre><code class="language-py">In [103]: df = pd.read_csv('tmp.csv', header=None, parse_dates=[[1, 2], [1, 3]],
 .....:                 keep_date_col=True)
 .....: 

In [104]: df
Out[104]: 
 1_2                 1_3     0         1          2          3     4
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  19990127   19:00:00   18:56:00  0.81
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  19990127   20:00:00   19:56:00  0.01
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD  19990127   21:00:00   20:56:00 -0.59
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD  19990127   21:00:00   21:18:00 -0.99
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD  19990127   22:00:00   21:56:00 -0.59
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD  19990127   23:00:00   22:56:00 -0.59
</code></pre>

<p>Note that if you wish to combine multiple columns into a single date column, a nested list must be used. In other words,  <code>parse_dates=[1,  2]</code>  indicates that the second and third columns should each be parsed as separate date columns while  <code>parse_dates=[[1,  2]]</code>  means the two columns should be parsed into a single column.</p>

<p>You can also use a dict to specify custom name columns:</p>

<pre><code class="language-py">In [105]: date_spec = {'nominal': [1, 2], 'actual': [1, 3]}

In [106]: df = pd.read_csv('tmp.csv', header=None, parse_dates=date_spec)

In [107]: df
Out[107]: 
 nominal              actual     0     4
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</code></pre>

<p>It is important to remember that if multiple text columns are to be parsed into a single date column, then a new column is prepended to the data. The  index_col  specification is based off of this new set of columns rather than the original data columns:</p>

<pre><code class="language-py">In [108]: date_spec = {'nominal': [1, 2], 'actual': [1, 3]}

In [109]: df = pd.read_csv('tmp.csv', header=None, parse_dates=date_spec,
 .....:                 index_col=0)  # index is the nominal column
 .....: 

In [110]: df
Out[110]: 
 actual     0     4
nominal 
1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</code></pre>

<blockquote>
<p>Note</p>

<p>If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html#pandas.to_datetime" title="pandas.to_datetime"><code>to_datetime()</code></a>  after  <code>pd.read_csv</code>.</p>
</blockquote>

<p><blockquote class="book-hint info">
  <p><strong>Note</strong></p>

<p>read_csv has a fast_path for parsing datetime strings in iso8601 format, e.g “2000-01-01T00:01:02+00:00” and similar variations. If you can arrange for your data to store datetimes in this format, load times will be significantly faster, ~20x has been observed.</p>

</blockquote>

<strong>Note</strong></p>

<p>When passing a dict as the  parse_dates  argument, the order of the columns prepended is not guaranteed, because  dict  objects do not impose an ordering on their keys. On Python 2.7+ you may use  collections.OrderedDict  instead of a regular  dict  if this matters to you. Because of this, when using a dict for ‘parse_dates’ in conjunction with the  index_col  argument, it’s best to specify  index_col  as a column label rather then as an index on the resulting frame.</p>

<h4 id="date-parsing-functions-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-date-parsing-functions-permalink-to-this-headline">Date parsing functions[](<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#date-parsing-functions">https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#date-parsing-functions</a> &ldquo;Permalink to this headline&rdquo;)</h4>

<p>Finally, the parser allows you to specify a custom  <code>date_parser</code>  function to take full advantage of the flexibility of the date parsing API:</p>

<pre><code class="language-py">In [111]: df = pd.read_csv('tmp.csv', header=None, parse_dates=date_spec,
 .....:                 date_parser=pd.io.date_converters.parse_date_time)
 .....: 

In [112]: df
Out[112]: 
 nominal              actual     0     4
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</code></pre>

<p>Pandas will try to call the  <code>date_parser</code>  function in three different ways. If an exception is raised, the next one is tried:</p>

<ol>
<li><p><code>date_parser</code>  is first called with one or more arrays as arguments, as defined using  parse_dates  (e.g.,  <code>date_parser(['2013',  '2013'],  ['1',  '2'])</code>).</p></li>

<li><p>If #1 fails,  <code>date_parser</code>  is called with all the columns concatenated row-wise into a single array (e.g.,  <code>date_parser(['2013  1',  '2013  2'])</code>).</p></li>

<li><p>If #2 fails,  <code>date_parser</code>  is called once for every row with one or more string arguments from the columns indicated with  parse_dates  (e.g.,  <code>date_parser('2013',  '1')</code>  for the first row,  <code>date_parser('2013',  '2')</code>  for the second, etc.).</p></li>
</ol>

<p>Note that performance-wise, you should try these methods of parsing dates in order:</p>

<ol>
<li><p>Try to infer the format using  <code>infer_datetime_format=True</code>  (see section below).</p></li>

<li><p>If you know the format, use  <code>pd.to_datetime()</code>:  <code>date_parser=lambda  x:  pd.to_datetime(x,  format=...)</code>.</p></li>

<li><p>If you have a really non-standard format, use a custom  <code>date_parser</code>  function. For optimal performance, this should be vectorized, i.e., it should accept arrays as arguments.</p></li>
</ol>

<p>You can explore the date parsing functionality in  <a href="https://github.com/pandas-dev/pandas/blob/master/pandas/io/date_converters.py">date_converters.py</a>  and add your own. We would love to turn this module into a community supported set of date/time parsers. To get you started,  <code>date_converters.py</code>  contains functions to parse dual date and time columns, year/month/day columns, and year/month/day/hour/minute/second columns. It also contains a  <code>generic_parser</code>  function so you can curry it with a function that deals with a single date rather than the entire array.</p>

<h4 id="parsing-a-csv-with-mixed-timezones-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-parsing-a-csv-with-mixed-timezones-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#parsing-a-csv-with-mixed-timezones" title="Permalink to this headline">Parsing a CSV with mixed timezones</a></h4>

<p>Pandas cannot natively represent a column or index with mixed timezones. If your CSV file contains columns with a mixture of timezones, the default result will be an object-dtype column with strings, even with  <code>parse_dates</code>.</p>

<pre><code class="language-py">In [113]: content = &quot;&quot;&quot;\
 .....: a
 .....: 2000-01-01T00:00:00+05:00
 .....: 2000-01-01T00:00:00+06:00&quot;&quot;&quot;
 .....: 

In [114]: df = pd.read_csv(StringIO(content), parse_dates=['a'])

In [115]: df['a']
Out[115]: 
0    2000-01-01 00:00:00+05:00
1    2000-01-01 00:00:00+06:00
Name: a, dtype: object
</code></pre>

<p>To parse the mixed-timezone values as a datetime column, pass a partially-applied  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html#pandas.to_datetime" title="pandas.to_datetime"><code>to_datetime()</code></a>  with  <code>utc=True</code>  as the  <code>date_parser</code>.</p>

<pre><code class="language-py">In [116]: df = pd.read_csv(StringIO(content), parse_dates=['a'],
 .....:                 date_parser=lambda col: pd.to_datetime(col, utc=True))
 .....: 

In [117]: df['a']
Out[117]: 
0   1999-12-31 19:00:00+00:00
1   1999-12-31 18:00:00+00:00
Name: a, dtype: datetime64[ns, UTC]
</code></pre>

<h4 id="inferring-datetime-format-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-inferring-datetime-format-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#inferring-datetime-format" title="Permalink to this headline">Inferring datetime format</a></h4>

<p>If you have  <code>parse_dates</code>  enabled for some or all of your columns, and your datetime strings are all formatted the same way, you may get a large speed up by setting  <code>infer_datetime_format=True</code>. If set, pandas will attempt to guess the format of your datetime strings, and then use a faster means of parsing the strings. 5-10x parsing speeds have been observed. pandas will fallback to the usual parsing if either the format cannot be guessed or the format that was guessed cannot properly parse the entire column of strings. So in general,  <code>infer_datetime_format</code>  should not have any negative consequences if enabled.</p>

<p>Here are some examples of datetime strings that can be guessed (All representing December 30th, 2011 at 00:00:00):</p>

<ul>
<li>“20111230”<br /></li>
<li>“2011/12/30”<br /></li>
<li>“20111230 00:00:00”<br /></li>
<li>“12/30/2011 00:00:00”<br /></li>
<li>“30/Dec/2011 00:00:00”<br /></li>
<li>“30/December/2011 00:00:00”
<br /></li>
</ul>

<p>Note that  <code>infer_datetime_format</code>  is sensitive to  <code>dayfirst</code>. With  <code>dayfirst=True</code>, it will guess “01/12/2011” to be December 1st. With  <code>dayfirst=False</code>  (default) it will guess “01/12/2011” to be January 12th.</p>

<pre><code class="language-py"># Try to infer the format for the index column
In [118]: df = pd.read_csv('foo.csv', index_col=0, parse_dates=True,
 .....:                 infer_datetime_format=True)
 .....: 

In [119]: df
Out[119]: 
 A  B  C
date 
2009-01-01  a  1  2
2009-01-02  b  3  4
2009-01-03  c  4  5
</code></pre>

<h4 id="international-date-formats-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-international-date-formats-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#international-date-formats" title="Permalink to this headline">International date formats</a></h4>

<p>While US date formats tend to be MM/DD/YYYY, many international formats use DD/MM/YYYY instead. For convenience, a  <code>dayfirst</code>  keyword is provided:</p>

<pre><code class="language-py">In [120]: print(open('tmp.csv').read())
date,value,cat
1/6/2000,5,a
2/6/2000,10,b
3/6/2000,15,c

In [121]: pd.read_csv('tmp.csv', parse_dates=[0])
Out[121]: 
 date  value cat
0 2000-01-06      5   a
1 2000-02-06     10   b
2 2000-03-06     15   c

In [122]: pd.read_csv('tmp.csv', dayfirst=True, parse_dates=[0])
Out[122]: 
 date  value cat
0 2000-06-01      5   a
1 2000-06-02     10   b
2 2000-06-03     15   c
</code></pre>

<h3 id="specifying-method-for-floating-point-conversion-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-specifying-method-for-floating-point-conversion-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#specifying-method-for-floating-point-conversion" title="Permalink to this headline">Specifying method for floating-point conversion</a></h3>

<p>The parameter  <code>float_precision</code>  can be specified in order to use a specific floating-point converter during parsing with the C engine. The options are the ordinary converter, the high-precision converter, and the round-trip converter (which is guaranteed to round-trip values after writing to a file). For example:</p>

<pre><code class="language-py">In [123]: val = '0.3066101993807095471566981359501369297504425048828125'

In [124]: data = 'a,b,c\n1,2,{0}'.format(val)

In [125]: abs(pd.read_csv(StringIO(data), engine='c',
 .....:                float_precision=None)['c'][0] - float(val))
 .....: 
Out[125]: 1.1102230246251565e-16

In [126]: abs(pd.read_csv(StringIO(data), engine='c',
 .....:                float_precision='high')['c'][0] - float(val))
 .....: 
Out[126]: 5.551115123125783e-17

In [127]: abs(pd.read_csv(StringIO(data), engine='c',
 .....:                float_precision='round_trip')['c'][0] - float(val))
 .....: 
Out[127]: 0.0
</code></pre>

<h3 id="thousand-separators-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-thousand-separators-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#thousand-separators" title="Permalink to this headline">Thousand separators</a></h3>

<p>For large numbers that have been written with a thousands separator, you can set the  <code>thousands</code>  keyword to a string of length 1 so that integers will be parsed correctly:</p>

<p>By default, numbers with a thousands separator will be parsed as strings:</p>

<pre><code class="language-py">In [128]: print(open('tmp.csv').read())
ID|level|category
Patient1|123,000|x
Patient2|23,000|y
Patient3|1,234,018|z

In [129]: df = pd.read_csv('tmp.csv', sep='|')

In [130]: df
Out[130]: 
 ID      level category
0  Patient1    123,000        x
1  Patient2     23,000        y
2  Patient3  1,234,018        z

In [131]: df.level.dtype
Out[131]: dtype('O')

The  `thousands`  keyword allows integers to be parsed correctly:

In [132]: print(open('tmp.csv').read())
ID|level|category
Patient1|123,000|x
Patient2|23,000|y
Patient3|1,234,018|z

In [133]: df = pd.read_csv('tmp.csv', sep='|', thousands=',')

In [134]: df
Out[134]: 
 ID    level category
0  Patient1   123000        x
1  Patient2    23000        y
2  Patient3  1234018        z

In [135]: df.level.dtype
Out[135]: dtype('int64')
</code></pre>

<h3 id="na-values-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-na-values-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#na-values" title="Permalink to this headline">NA values</a></h3>

<p>To control which values are parsed as missing values (which are signified by  <code>NaN</code>), specify a string in  <code>na_values</code>. If you specify a list of strings, then all values in it are considered to be missing values. If you specify a number (a  <code>float</code>, like  <code>5.0</code>  or an  <code>integer</code>  like  <code>5</code>), the corresponding equivalent values will also imply a missing value (in this case effectively  <code>[5.0,  5]</code>  are recognized as  <code>NaN</code>).</p>

<p>To completely override the default values that are recognized as missing, specify  <code>keep_default_na=False</code>.</p>

<p>The default  <code>NaN</code>  recognized values are  <code>['-1.#IND',  '1.#QNAN',  '1.#IND',  '-1.#QNAN',  '#N/A  N/A',  '#N/A',  'N/A',  'n/a',  'NA',  '&lt;NA&gt;',  '#NA',  'NULL',  'null',  'NaN',  '-NaN',  'nan',  '-nan',  '']</code>.</p>

<p>Let us consider some examples:</p>

<pre><code class="language-py">pd.read_csv('path_to_file.csv', na_values=[5])
</code></pre>

<p>In the example above  <code>5</code>  and  <code>5.0</code>  will be recognized as  <code>NaN</code>, in addition to the defaults. A string will first be interpreted as a numerical  <code>5</code>, then as a  <code>NaN</code>.</p>

<pre><code class="language-py">pd.read_csv('path_to_file.csv', keep_default_na=False, na_values=[&quot;&quot;])
</code></pre>

<p>Above, only an empty field will be recognized as  <code>NaN</code>.</p>

<pre><code class="language-py">pd.read_csv('path_to_file.csv', keep_default_na=False, na_values=[&quot;NA&quot;, &quot;0&quot;])
</code></pre>

<p>Above, both  <code>NA</code>  and  <code>0</code>  as strings are  <code>NaN</code>.</p>

<pre><code class="language-py">pd.read_csv('path_to_file.csv', na_values=[&quot;Nope&quot;])
</code></pre>

<p>The default values, in addition to the string  <code>&quot;Nope&quot;</code>  are recognized as  <code>NaN</code>.</p>

<h3 id="infinity-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-infinity-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#infinity" title="Permalink to this headline">Infinity</a></h3>

<p><code>inf</code>  like values will be parsed as  <code>np.inf</code>  (positive infinity), and  <code>-inf</code>  as  <code>-np.inf</code>  (negative infinity). These will ignore the case of the value, meaning  <code>Inf</code>, will also be parsed as  <code>np.inf</code>.</p>

<h3 id="returning-series-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-returning-series-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#returning-series" title="Permalink to this headline">Returning Series</a></h3>

<p>Using the  <code>squeeze</code>  keyword, the parser will return output with a single column as a  <code>Series</code>:</p>

<pre><code class="language-py">In [136]: print(open('tmp.csv').read())
level
Patient1,123000
Patient2,23000
Patient3,1234018

In [137]: output = pd.read_csv('tmp.csv', squeeze=True)

In [138]: output
Out[138]: 
Patient1     123000
Patient2      23000
Patient3    1234018
Name: level, dtype: int64

In [139]: type(output)
Out[139]: pandas.core.series.Series
</code></pre>

<h3 id="boolean-values-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-boolean-values-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#boolean-values" title="Permalink to this headline">Boolean values</a></h3>

<p>The common values  <code>True</code>,  <code>False</code>,  <code>TRUE</code>, and  <code>FALSE</code>  are all recognized as boolean. Occasionally you might want to recognize other values as being boolean. To do this, use the  <code>true_values</code>  and  <code>false_values</code>  options as follows:</p>

<pre><code class="language-py">In [140]: data = ('a,b,c\n'
 .....:        '1,Yes,2\n'
 .....:        '3,No,4')
 .....: 

In [141]: print(data)
a,b,c
1,Yes,2
3,No,4

In [142]: pd.read_csv(StringIO(data))
Out[142]: 
 a    b  c
0  1  Yes  2
1  3   No  4

In [143]: pd.read_csv(StringIO(data), true_values=['Yes'], false_values=['No'])
Out[143]: 
 a      b  c
0  1   True  2
1  3  False  4
</code></pre>

<h3 id="handling-bad-lines-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-handling-bad-lines-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#handling-bad-lines" title="Permalink to this headline">Handling “bad” lines</a></h3>

<p>Some files may have malformed lines with too few fields or too many. Lines with too few fields will have NA values filled in the trailing fields. Lines with too many fields will raise an error by default:</p>

<pre><code class="language-py">In [144]: data = ('a,b,c\n'
 .....:        '1,2,3\n'
 .....:        '4,5,6,7\n'
 .....:        '8,9,10')
 .....: 

In [145]: pd.read_csv(StringIO(data))
---------------------------------------------------------------------------
ParserError  Traceback (most recent call last)
&lt;ipython-input-145-6388c394e6b8&gt; in &lt;module&gt;
----&gt; 1 pd.read_csv(StringIO(data))

/pandas/pandas/io/parsers.py in parser_f(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, squeeze, prefix, mangle_dupe_cols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, dialect, error_bad_lines, warn_bad_lines, delim_whitespace, low_memory, memory_map, float_precision)
  674         )
  675 
--&gt; 676         return _read(filepath_or_buffer, kwds)
  677 
  678     parser_f.__name__ = name

/pandas/pandas/io/parsers.py in _read(filepath_or_buffer, kwds)
  452 
  453     try:
--&gt; 454         data = parser.read(nrows)
  455     finally:
  456         parser.close()

/pandas/pandas/io/parsers.py in read(self, nrows)
  1131     def read(self, nrows=None):
  1132         nrows = _validate_integer(&quot;nrows&quot;, nrows)
-&gt; 1133         ret = self._engine.read(nrows)
  1134 
  1135         # May alter columns / col_dict

/pandas/pandas/io/parsers.py in read(self, nrows)
  2035     def read(self, nrows=None):
  2036         try:
-&gt; 2037             data = self._reader.read(nrows)
  2038         except StopIteration:
  2039             if self._first_chunk:

/pandas/pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader.read()

/pandas/pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader._read_low_memory()

/pandas/pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader._read_rows()

/pandas/pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader._tokenize_rows()

/pandas/pandas/_libs/parsers.pyx in pandas._libs.parsers.raise_parser_error()
</code></pre>

<p>ParserError: Error tokenizing data. C error: Expected 3 fields in line 3, saw 4</p>

<p>You can elect to skip bad lines:</p>

<pre><code class="language-py">In [29]: pd.read_csv(StringIO(data), error_bad_lines=False)
Skipping line 3: expected 3 fields, saw 4
</code></pre>

<pre><code class="language-py">Out[29]:
 a  b   c
0  1  2   3
1  8  9  10
</code></pre>

<p>You can also use the  <code>usecols</code>  parameter to eliminate extraneous column data that appear in some lines but not others:</p>

<pre><code class="language-py">In [30]: pd.read_csv(StringIO(data), usecols=[0, 1, 2])

 Out[30]:
 a  b   c
 0  1  2   3
 1  4  5   6
 2  8  9  10
</code></pre>

<h3 id="dialect-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-dialect-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#dialect" title="Permalink to this headline">Dialect</a></h3>

<p>The  <code>dialect</code>  keyword gives greater flexibility in specifying the file format. By default it uses the Excel dialect but you can specify either the dialect name or a  <a href="https://docs.python.org/3/library/csv.html#csv.Dialect &quot;(in Python v3.8"><code>csv.Dialect</code></a>&rdquo;)  instance.</p>

<p>Suppose you had data with unenclosed quotes:</p>

<pre><code class="language-py">In [146]: print(data)
label1,label2,label3
index1,&quot;a,c,e
index2,b,d,f
</code></pre>

<p>By default,  <code>read_csv</code>  uses the Excel dialect and treats the double quote as the quote character, which causes it to fail when it finds a newline before it finds the closing double quote.</p>

<p>We can get around this using  <code>dialect</code>:</p>

<pre><code class="language-py">In [147]: import csv

In [148]: dia = csv.excel()

In [149]: dia.quoting = csv.QUOTE_NONE

In [150]: pd.read_csv(StringIO(data), dialect=dia)
Out[150]: 
 label1 label2 label3
index1     &quot;a      c      e
index2      b      d      f
</code></pre>

<p>All of the dialect options can be specified separately by keyword arguments:</p>

<pre><code class="language-py">In [151]: data = 'a,b,c~1,2,3~4,5,6'

In [152]: pd.read_csv(StringIO(data), lineterminator='~')
Out[152]: 
 a  b  c
0  1  2  3
1  4  5  6
</code></pre>

<p>Another common dialect option is  <code>skipinitialspace</code>, to skip any whitespace after a delimiter:</p>

<pre><code class="language-py">In [153]: data = 'a, b, c\n1, 2, 3\n4, 5, 6'

In [154]: print(data)
a, b, c
1, 2, 3
4, 5, 6

In [155]: pd.read_csv(StringIO(data), skipinitialspace=True)
Out[155]: 
 a  b  c
0  1  2  3
1  4  5  6
</code></pre>

<p>The parsers make every attempt to “do the right thing” and not be fragile. Type inference is a pretty big deal. If a column can be coerced to integer dtype without altering the contents, the parser will do so. Any non-numeric columns will come through as object dtype as with the rest of pandas objects.</p>

<h3 id="quoting-and-escape-characters-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-quoting-and-escape-characters-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#quoting-and-escape-characters" title="Permalink to this headline">Quoting and Escape Characters</a></h3>

<p>Quotes (and other escape characters) in embedded fields can be handled in any number of ways. One way is to use backslashes; to properly parse this data, you should pass the  <code>escapechar</code>  option:</p>

<pre><code class="language-py">In [156]: data = 'a,b\n&quot;hello, \\&quot;Bob\\&quot;, nice to see you&quot;,5'

In [157]: print(data)
a,b
&quot;hello, \&quot;Bob\&quot;, nice to see you&quot;,5

In [158]: pd.read_csv(StringIO(data), escapechar='\\')
Out[158]: 
 a  b
0  hello, &quot;Bob&quot;, nice to see you  5
</code></pre>

<h3 id="files-with-fixed-width-columns-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-files-with-fixed-width-columns-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#files-with-fixed-width-columns" title="Permalink to this headline">Files with fixed width columns</a></h3>

<p>While  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code>read_csv()</code></a>  reads delimited data, the  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_fwf.html#pandas.read_fwf" title="pandas.read_fwf"><code>read_fwf()</code></a>  function works with data files that have known and fixed column widths. The function parameters to  <code>read_fwf</code>  are largely the same as  read_csv  with two extra parameters, and a different usage of the  <code>delimiter</code>  parameter:</p>

<ul>
<li><p><code>colspecs</code>: A list of pairs (tuples) giving the extents of the fixed-width fields of each line as half-open intervals (i.e., [from, to[ ). String value ‘infer’ can be used to instruct the parser to try detecting the column specifications from the first 100 rows of the data. Default behavior, if not specified, is to infer.</p></li>

<li><p><code>widths</code>: A list of field widths which can be used instead of ‘colspecs’ if the intervals are contiguous.</p></li>

<li><p><code>delimiter</code>: Characters to consider as filler characters in the fixed-width file. Can be used to specify the filler character of the fields if it is not spaces (e.g., ‘~’).</p></li>
</ul>

<p>Consider a typical fixed-width data file:</p>

<pre><code class="language-py">In [159]: print(open('bar.csv').read())
id8141    360.242940   149.910199   11950.7
id1594    444.953632   166.985655   11788.4
id1849    364.136849   183.628767   11806.2
id1230    413.836124   184.375703   11916.8
id1948    502.953953   173.237159   12468.3
</code></pre>

<p>In order to parse this file into a  <code>DataFrame</code>, we simply need to supply the column specifications to the  read_fwf  function along with the file name:</p>

<pre><code class="language-py"># Column specifications are a list of half-intervals
In [160]: colspecs = [(0, 6), (8, 20), (21, 33), (34, 43)]

In [161]: df = pd.read_fwf('bar.csv', colspecs=colspecs, header=None, index_col=0)

In [162]: df
Out[162]: 
 1           2        3
0 
id8141  360.242940  149.910199  11950.7
id1594  444.953632  166.985655  11788.4
id1849  364.136849  183.628767  11806.2
id1230  413.836124  184.375703  11916.8
id1948  502.953953  173.237159  12468.3
</code></pre>

<p>Note how the parser automatically picks column names X.<column number> when  <code>header=None</code>  argument is specified. Alternatively, you can supply just the column widths for contiguous columns:</p>

<pre><code class="language-py"># Widths are a list of integers
In [163]: widths = [6, 14, 13, 10]

In [164]: df = pd.read_fwf('bar.csv', widths=widths, header=None)

In [165]: df
Out[165]: 
 0           1           2        3
0  id8141  360.242940  149.910199  11950.7
1  id1594  444.953632  166.985655  11788.4
2  id1849  364.136849  183.628767  11806.2
3  id1230  413.836124  184.375703  11916.8
4  id1948  502.953953  173.237159  12468.3
</code></pre>

<p>The parser will take care of extra white spaces around the columns so it’s ok to have extra separation between the columns in the file.</p>

<p>By default,  <code>read_fwf</code>  will try to infer the file’s  <code>colspecs</code>  by using the first 100 rows of the file. It can do it only in cases when the columns are aligned and correctly separated by the provided  <code>delimiter</code>  (default delimiter is whitespace).</p>

<pre><code class="language-py">In [166]: df = pd.read_fwf('bar.csv', header=None, index_col=0)

In [167]: df
Out[167]: 
 1           2        3
0 
id8141  360.242940  149.910199  11950.7
id1594  444.953632  166.985655  11788.4
id1849  364.136849  183.628767  11806.2
id1230  413.836124  184.375703  11916.8
id1948  502.953953  173.237159  12468.3
</code></pre>

<p><code>read_fwf</code>  supports the  <code>dtype</code>  parameter for specifying the types of parsed columns to be different from the inferred type.</p>

<pre><code class="language-py">In [168]: pd.read_fwf('bar.csv', header=None, index_col=0).dtypes
Out[168]: 
1    float64
2    float64
3    float64
dtype: object

In [169]: pd.read_fwf('bar.csv', header=None, dtype={2: 'object'}).dtypes
Out[169]: 
0     object
1    float64
2     object
3    float64
dtype: object
</code></pre>

<h3 id="indexes-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-indexes-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#indexes" title="Permalink to this headline">Indexes</a></h3>

<h4 id="files-with-an-implicit-index-column-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-files-with-an-implicit-index-column-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#files-with-an-implicit-index-column" title="Permalink to this headline">Files with an “implicit” index column</a></h4>

<p>Consider a file with one less entry in the header than the number of data column:</p>

<pre><code class="language-py">In [170]: print(open('foo.csv').read())
A,B,C
20090101,a,1,2
20090102,b,3,4
20090103,c,4,5
</code></pre>

<p>In this special case,  <code>read_csv</code>  assumes that the first column is to be used as the index of the  <code>DataFrame</code>:</p>

<pre><code class="language-py">In [171]: pd.read_csv('foo.csv')
Out[171]: 
 A  B  C
20090101  a  1  2
20090102  b  3  4
20090103  c  4  5
</code></pre>

<p>Note that the dates weren’t automatically parsed. In that case you would need to do as before:</p>

<pre><code class="language-py">In [172]: df = pd.read_csv('foo.csv', parse_dates=True)

In [173]: df.index
Out[173]: DatetimeIndex(['2009-01-01', '2009-01-02', '2009-01-03'], dtype='datetime64[ns]', freq=None)
</code></pre>

<h4 id="reading-an-index-with-a-multiindex-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-reading-an-index-with-a-multiindex-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#reading-an-index-with-a-multiindex" title="Permalink to this headline">Reading an index with a  <code>MultiIndex</code></a></h4>

<p>Suppose you have data indexed by two columns:</p>

<pre><code class="language-py">In [174]: print(open('data/mindex_ex.csv').read())
year,indiv,zit,xit
1977,&quot;A&quot;,1.2,.6
1977,&quot;B&quot;,1.5,.5
1977,&quot;C&quot;,1.7,.8
1978,&quot;A&quot;,.2,.06
1978,&quot;B&quot;,.7,.2
1978,&quot;C&quot;,.8,.3
1978,&quot;D&quot;,.9,.5
1978,&quot;E&quot;,1.4,.9
1979,&quot;C&quot;,.2,.15
1979,&quot;D&quot;,.14,.05
1979,&quot;E&quot;,.5,.15
1979,&quot;F&quot;,1.2,.5
1979,&quot;G&quot;,3.4,1.9
1979,&quot;H&quot;,5.4,2.7
1979,&quot;I&quot;,6.4,1.2
</code></pre>

<p>The  <code>index_col</code>  argument to  <code>read_csv</code>  can take a list of column numbers to turn multiple columns into a  <code>MultiIndex</code>  for the index of the returned object:</p>

<pre><code class="language-py">In [175]: df = pd.read_csv(&quot;data/mindex_ex.csv&quot;, index_col=[0, 1])

In [176]: df
Out[176]: 
 zit   xit
year indiv 
1977 A      1.20  0.60
 B      1.50  0.50
 C      1.70  0.80
1978 A      0.20  0.06
 B      0.70  0.20
 C      0.80  0.30
 D      0.90  0.50
 E      1.40  0.90
1979 C      0.20  0.15
 D      0.14  0.05
 E      0.50  0.15
 F      1.20  0.50
 G      3.40  1.90
 H      5.40  2.70
 I      6.40  1.20

In [177]: df.loc[1978]
Out[177]: 
 zit   xit
indiv 
A      0.2  0.06
B      0.7  0.20
C      0.8  0.30
D      0.9  0.50
E      1.4  0.90
</code></pre>

<h4 id="reading-columns-with-a-multiindex-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-reading-columns-with-a-multiindex-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#reading-columns-with-a-multiindex" title="Permalink to this headline">Reading columns with a  <code>MultiIndex</code></a></h4>

<p>By specifying list of row locations for the  <code>header</code>  argument, you can read in a  <code>MultiIndex</code>  for the columns. Specifying non-consecutive rows will skip the intervening rows.</p>

<pre><code class="language-py">In [178]: from pandas._testing import makeCustomDataframe as mkdf

In [179]: df = mkdf(5, 3, r_idx_nlevels=2, c_idx_nlevels=4)

In [180]: df.to_csv('mi.csv')

In [181]: print(open('mi.csv').read())
C0,,C_l0_g0,C_l0_g1,C_l0_g2
C1,,C_l1_g0,C_l1_g1,C_l1_g2
C2,,C_l2_g0,C_l2_g1,C_l2_g2
C3,,C_l3_g0,C_l3_g1,C_l3_g2
R0,R1,,,
R_l0_g0,R_l1_g0,R0C0,R0C1,R0C2
R_l0_g1,R_l1_g1,R1C0,R1C1,R1C2
R_l0_g2,R_l1_g2,R2C0,R2C1,R2C2
R_l0_g3,R_l1_g3,R3C0,R3C1,R3C2
R_l0_g4,R_l1_g4,R4C0,R4C1,R4C2

In [182]: pd.read_csv('mi.csv', header=[0, 1, 2, 3], index_col=[0, 1])
Out[182]: 
C0              C_l0_g0 C_l0_g1 C_l0_g2
C1              C_l1_g0 C_l1_g1 C_l1_g2
C2              C_l2_g0 C_l2_g1 C_l2_g2
C3              C_l3_g0 C_l3_g1 C_l3_g2
R0      R1 
R_l0_g0 R_l1_g0    R0C0    R0C1    R0C2
R_l0_g1 R_l1_g1    R1C0    R1C1    R1C2
R_l0_g2 R_l1_g2    R2C0    R2C1    R2C2
R_l0_g3 R_l1_g3    R3C0    R3C1    R3C2
R_l0_g4 R_l1_g4    R4C0    R4C1    R4C2
</code></pre>

<p><code>read_csv</code>  is also able to interpret a more common format of multi-columns indices.</p>

<pre><code class="language-py">In [183]: print(open('mi2.csv').read())
,a,a,a,b,c,c
,q,r,s,t,u,v
one,1,2,3,4,5,6
two,7,8,9,10,11,12

In [184]: pd.read_csv('mi2.csv', header=[0, 1], index_col=0)
Out[184]: 
 a         b   c 
 q  r  s   t   u   v
one  1  2  3   4   5   6
two  7  8  9  10  11  12
</code></pre>

<p>Note: If an  <code>index_col</code>  is not specified (e.g. you don’t have an index, or wrote it with  <code>df.to_csv(...,  index=False)</code>, then any  <code>names</code>  on the columns index will be  <em>lost</em>.</p>

<h3 id="automatically-sniffing-the-delimiter-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-automatically-sniffing-the-delimiter-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#automatically-sniffing-the-delimiter" title="Permalink to this headline">Automatically “sniffing” the delimiter</a></h3>

<p><code>read_csv</code>  is capable of inferring delimited (not necessarily comma-separated) files, as pandas uses the  <a href="https://docs.python.org/3/library/csv.html#csv.Sniffer &quot;(in Python v3.8"><code>csv.Sniffer</code></a>&rdquo;)  class of the csv module. For this, you have to specify  <code>sep=None</code>.</p>

<pre><code class="language-py">In [185]: print(open('tmp2.sv').read())
:0:1:2:3
0:0.4691122999071863:-0.2828633443286633:-1.5090585031735124:-1.1356323710171934
1:1.2121120250208506:-0.17321464905330858:0.11920871129693428:-1.0442359662799567
2:-0.8618489633477999:-2.1045692188948086:-0.4949292740687813:1.071803807037338
3:0.7215551622443669:-0.7067711336300845:-1.0395749851146963:0.27185988554282986
4:-0.42497232978883753:0.567020349793672:0.27623201927771873:-1.0874006912859915
5:-0.6736897080883706:0.1136484096888855:-1.4784265524372235:0.5249876671147047
6:0.4047052186802365:0.5770459859204836:-1.7150020161146375:-1.0392684835147725
7:-0.3706468582364464:-1.1578922506419993:-1.344311812731667:0.8448851414248841
8:1.0757697837155533:-0.10904997528022223:1.6435630703622064:-1.4693879595399115
9:0.35702056413309086:-0.6746001037299882:-1.776903716971867:-0.9689138124473498

In [186]: pd.read_csv('tmp2.sv', sep=None, engine='python')
Out[186]: 
 Unnamed: 0         0         1         2         3
0           0  0.469112 -0.282863 -1.509059 -1.135632
1           1  1.212112 -0.173215  0.119209 -1.044236
2           2 -0.861849 -2.104569 -0.494929  1.071804
3           3  0.721555 -0.706771 -1.039575  0.271860
4           4 -0.424972  0.567020  0.276232 -1.087401
5           5 -0.673690  0.113648 -1.478427  0.524988
6           6  0.404705  0.577046 -1.715002 -1.039268
7           7 -0.370647 -1.157892 -1.344312  0.844885
8           8  1.075770 -0.109050  1.643563 -1.469388
9           9  0.357021 -0.674600 -1.776904 -0.968914
</code></pre>

<h3 id="reading-multiple-files-to-create-a-single-dataframe-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-reading-multiple-files-to-create-a-single-dataframe-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#reading-multiple-files-to-create-a-single-dataframe" title="Permalink to this headline">Reading multiple files to create a single DataFrame</a></h3>

<p>It’s best to use  <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html#pandas.concat" title="pandas.concat"><code>concat()</code></a>  to combine multiple files. See the  <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/cookbook.html#cookbook-csv-multiple-files">cookbook</a>  for an example.</p>

<h3 id="iterating-through-files-chunk-by-chunk-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-iterating-through-files-chunk-by-chunk-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#iterating-through-files-chunk-by-chunk" title="Permalink to this headline">Iterating through files chunk by chunk</a></h3>

<p>Suppose you wish to iterate through a (potentially very large) file lazily rather than reading the entire file into memory, such as the following:</p>

<pre><code class="language-py">In [187]: print(open('tmp.sv').read())
|0|1|2|3
0|0.4691122999071863|-0.2828633443286633|-1.5090585031735124|-1.1356323710171934
1|1.2121120250208506|-0.17321464905330858|0.11920871129693428|-1.0442359662799567
2|-0.8618489633477999|-2.1045692188948086|-0.4949292740687813|1.071803807037338
3|0.7215551622443669|-0.7067711336300845|-1.0395749851146963|0.27185988554282986
4|-0.42497232978883753|0.567020349793672|0.27623201927771873|-1.0874006912859915
5|-0.6736897080883706|0.1136484096888855|-1.4784265524372235|0.5249876671147047
6|0.4047052186802365|0.5770459859204836|-1.7150020161146375|-1.0392684835147725
7|-0.3706468582364464|-1.1578922506419993|-1.344311812731667|0.8448851414248841
8|1.0757697837155533|-0.10904997528022223|1.6435630703622064|-1.4693879595399115
9|0.35702056413309086|-0.6746001037299882|-1.776903716971867|-0.9689138124473498

In [188]: table = pd.read_csv('tmp.sv', sep='|')

In [189]: table
Out[189]: 
 Unnamed: 0         0         1         2         3
0           0  0.469112 -0.282863 -1.509059 -1.135632
1           1  1.212112 -0.173215  0.119209 -1.044236
2           2 -0.861849 -2.104569 -0.494929  1.071804
3           3  0.721555 -0.706771 -1.039575  0.271860
4           4 -0.424972  0.567020  0.276232 -1.087401
5           5 -0.673690  0.113648 -1.478427  0.524988
6           6  0.404705  0.577046 -1.715002 -1.039268
7           7 -0.370647 -1.157892 -1.344312  0.844885
8           8  1.075770 -0.109050  1.643563 -1.469388
9           9  0.357021 -0.674600 -1.776904 -0.968914
</code></pre>

<p>By specifying a  <code>chunksize</code>  to  <code>read_csv</code>, the return value will be an iterable object of type  <code>TextFileReader</code>:</p>

<pre><code class="language-py">In [190]: reader = pd.read_csv('tmp.sv', sep='|', chunksize=4)

In [191]: reader
Out[191]: &lt;pandas.io.parsers.TextFileReader at 0x7f9184154b50&gt;

In [192]: for chunk in reader:
 .....:    print(chunk)
 .....: 
 Unnamed: 0         0         1         2         3
0           0  0.469112 -0.282863 -1.509059 -1.135632
1           1  1.212112 -0.173215  0.119209 -1.044236
2           2 -0.861849 -2.104569 -0.494929  1.071804
3           3  0.721555 -0.706771 -1.039575  0.271860
 Unnamed: 0         0         1         2         3
4           4 -0.424972  0.567020  0.276232 -1.087401
5           5 -0.673690  0.113648 -1.478427  0.524988
6           6  0.404705  0.577046 -1.715002 -1.039268
7           7 -0.370647 -1.157892 -1.344312  0.844885
 Unnamed: 0         0        1         2         3
8           8  1.075770 -0.10905  1.643563 -1.469388
9           9  0.357021 -0.67460 -1.776904 -0.968914

Specifying  `iterator=True`  will also return the  `TextFileReader`  object:

In [193]: reader = pd.read_csv('tmp.sv', sep='|', iterator=True)

In [194]: reader.get_chunk(5)
Out[194]: 
 Unnamed: 0         0         1         2         3
0           0  0.469112 -0.282863 -1.509059 -1.135632
1           1  1.212112 -0.173215  0.119209 -1.044236
2           2 -0.861849 -2.104569 -0.494929  1.071804
3           3  0.721555 -0.706771 -1.039575  0.271860
4           4 -0.424972  0.567020  0.276232 -1.087401
</code></pre>

<h3 id="specifying-the-parser-engine-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-specifying-the-parser-engine-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#specifying-the-parser-engine" title="Permalink to this headline">Specifying the parser engine</a></h3>

<p>Under the hood pandas uses a fast and efficient parser implemented in C as well as a Python implementation which is currently more feature-complete. Where possible pandas uses the C parser (specified as  <code>engine='c'</code>), but may fall back to Python if C-unsupported options are specified. Currently, C-unsupported options include:</p>

<ul>
<li><p><code>sep</code>  other than a single character (e.g. regex separators)</p></li>

<li><p><code>skipfooter</code></p></li>

<li><p><code>sep=None</code>  with  <code>delim_whitespace=False</code></p></li>
</ul>

<p>Specifying any of the above options will produce a  <code>ParserWarning</code>  unless the python engine is selected explicitly using  <code>engine='python'</code>.</p>

<h3 id="reading-remote-files-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-reading-remote-files-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#reading-remote-files" title="Permalink to this headline">Reading remote files</a></h3>

<p>You can pass in a URL to a CSV file:</p>

<pre><code class="language-py">df = pd.read_csv('https://download.bls.gov/pub/time.series/cu/cu.item',
                 sep='\t')
</code></pre>

<p>S3 URLs are handled as well but require installing the  <a href="https://pypi.org/project/s3fs/">S3Fs</a>  library:</p>

<pre><code class="language-py">df = pd.read_csv('s3://pandas-test/tips.csv')
</code></pre>

<p>If your S3 bucket requires credentials you will need to set them as environment variables or in the  <code>~/.aws/credentials</code>  config file, refer to the  <a href="https://s3fs.readthedocs.io/en/latest/#credentials">S3Fs documentation on credentials</a>.</p>

<h3 id="writing-out-data-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-writing-out-data-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#writing-out-data" title="Permalink to this headline">Writing out data</a></h3>

<h4 id="writing-to-csv-format-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-writing-to-csv-format-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#writing-to-csv-format" title="Permalink to this headline">Writing to CSV format</a></h4>

<p>The  <code>Series</code>  and  <code>DataFrame</code>  objects have an instance method  <code>to_csv</code>  which allows storing the contents of the object as a comma-separated-values file. The function takes a number of arguments. Only the first is required.</p>

<ul>
<li><code>path_or_buf</code>: A string path to the file to write or a file object. If a file object it must be opened with  newline=’’<br /></li>
<li><code>sep</code>  : Field delimiter for the output file (default “,”)<br /></li>
<li><code>na_rep</code>: A string representation of a missing value (default ‘’)<br /></li>
<li><code>float_format</code>: Format string for floating point numbers<br /></li>
<li><code>columns</code>: Columns to write (default None)<br /></li>
<li><code>header</code>: Whether to write out the column names (default True)<br /></li>
<li><code>index</code>: whether to write row (index) names (default True)<br /></li>

<li><p><code>index_label</code>: Column label(s) for index column(s) if desired. If None (default), and  header  and  index  are True, then the index names are used. (A sequence should be given if the  <code>DataFrame</code>  uses MultiIndex).</p></li>

<li><p><code>mode</code>  : Python write mode, default ‘w’</p></li>

<li><p><code>encoding</code>: a string representing the encoding to use if the contents are non-ASCII, for Python versions prior to 3</p></li>

<li><p><code>line_terminator</code>: Character sequence denoting line end (default  os.linesep)</p></li>

<li><p><code>quoting</code>: Set quoting rules as in csv module (default csv.QUOTE_MINIMAL). Note that if you have set a  float_format  then floats are converted to strings and csv.QUOTE_NONNUMERIC will treat them as non-numeric</p></li>

<li><p><code>quotechar</code>: Character used to quote fields (default ‘”’)</p></li>

<li><p><code>doublequote</code>: Control quoting of  <code>quotechar</code>  in fields (default True)</p></li>

<li><p><code>escapechar</code>: Character used to escape  <code>sep</code>  and  <code>quotechar</code>  when appropriate (default None)</p></li>

<li><p><code>chunksize</code>: Number of rows to write at a time</p></li>

<li><p><code>date_format</code>: Format string for datetime objects</p></li>
</ul>

<h4 id="writing-a-formatted-string-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-writing-a-formatted-string-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#writing-a-formatted-string" title="Permalink to this headline">Writing a formatted string</a></h4>

<p>The  <code>DataFrame</code>  object has an instance method  <code>to_string</code>  which allows control over the string representation of the object. All arguments are optional:</p>

<ul>
<li><code>buf</code>  default None, for example a StringIO object<br /></li>
<li><code>columns</code>  default None, which columns to write<br /></li>
<li><code>col_space</code>  default None, minimum width of each column.<br /></li>
<li><code>na_rep</code>  default  <code>NaN</code>, representation of NA value<br /></li>
<li><code>formatters</code>  default None, a dictionary (by column) of functions each of which takes a single argument and returns a formatted string<br /></li>
<li><code>float_format</code>  default None, a function which takes a single (float) argument and returns a formatted string; to be applied to floats in the  <code>DataFrame</code>.<br /></li>
<li><code>sparsify</code>  default True, set to False for a  <code>DataFrame</code>  with a hierarchical index to print every MultiIndex key at each row.<br /></li>
<li><code>index_names</code>  default True, will print the names of the indices<br /></li>
<li><code>index</code>  default True, will print the index (ie, row labels)<br /></li>
<li><code>header</code>  default True, will print the column labels<br /></li>
<li><code>justify</code>  default  <code>left</code>, will print column headers left- or right-justified<br /></li>
</ul>

<p>The  <code>Series</code>  object also has a  <code>to_string</code>  method, but with only the  <code>buf</code>,  <code>na_rep</code>,  <code>float_format</code>  arguments. There is also a  <code>length</code>  argument which, if set to  <code>True</code>, will additionally output the length of the Series.</p>

<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html">Source : </a>.</p>
</blockquote>
</article>

      <div class="book-footer justify-between">
  

  

  
  <div>
    <a class="flex align-center" href="https://github.com/alex-shpak/hugo-book/edit/master/exampleSite/content/docs%5cPython%5cPandas%5c1_IO%5ccsv-and-text-file.md" target="_blank">
      <img src="/library/tutorials/svg/edit.svg" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>
  

</div>

      
    </div>

    
  

  <aside class="book-toc levels-true fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#csv-text-files-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-csv-text-files-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#csv-text-files" title="Permalink to this headline">CSV &amp; Text files</a></a>
<ul>
<li>
<ul>
<li><a href="#parsing-options-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-parsing-options-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#parsing-options" title="Permalink to this headline">Parsing options</a></a>
<ul>
<li><a href="#basic-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-basic-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#basic" title="Permalink to this headline">Basic</a></a></li>
<li><a href="#column-and-index-locations-and-names-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-column-and-index-locations-and-names-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#column-and-index-locations-and-names" title="Permalink to this headline">Column and index locations and names</a></a></li>
<li><a href="#general-parsing-configuration-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-general-parsing-configuration-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#general-parsing-configuration" title="Permalink to this headline">General parsing configuration</a></a></li>
<li><a href="#na-and-missing-data-handling-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-na-and-missing-data-handling-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#na-and-missing-data-handling" title="Permalink to this headline">NA and missing data handling</a></a></li>
<li><a href="#datetime-handling-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-datetime-handling-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#datetime-handling" title="Permalink to this headline">Datetime handling</a></a></li>
<li><a href="#iteration-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-iteration-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#iteration" title="Permalink to this headline">Iteration</a></a></li>
<li><a href="#quoting-compression-and-file-format-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-quoting-compression-and-file-format-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#quoting-compression-and-file-format" title="Permalink to this headline">Quoting, compression, and file format</a></a></li>
<li><a href="#error-handling-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-error-handling-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#error-handling" title="Permalink to this headline">Error handling</a></a></li>
</ul></li>
<li><a href="#specifying-column-data-types-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-specifying-column-data-types-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#specifying-column-data-types" title="Permalink to this headline">Specifying column data types</a></a></li>
<li><a href="#specifying-categorical-dtype-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-specifying-categorical-dtype-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#specifying-categorical-dtype" title="Permalink to this headline">Specifying categorical dtype</a></a></li>
<li><a href="#naming-and-using-columns-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-naming-and-using-columns-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#naming-and-using-columns" title="Permalink to this headline">Naming and using columns</a></a>
<ul>
<li><a href="#handling-column-names-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-handling-column-names-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#handling-column-names" title="Permalink to this headline">Handling column names</a></a></li>
</ul></li>
<li><a href="#duplicate-names-parsing-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-duplicate-names-parsing-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#duplicate-names-parsing" title="Permalink to this headline">Duplicate names parsing</a></a>
<ul>
<li><a href="#filtering-columns-usecols-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-filtering-columns-usecols-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#filtering-columns-usecols" title="Permalink to this headline">Filtering columns (<code>usecols</code>)</a></a></li>
</ul></li>
<li><a href="#comments-and-empty-lines-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-comments-and-empty-lines-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#comments-and-empty-lines" title="Permalink to this headline">Comments and empty lines</a></a>
<ul>
<li><a href="#ignoring-line-comments-and-empty-lines-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-ignoring-line-comments-and-empty-lines-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#ignoring-line-comments-and-empty-lines" title="Permalink to this headline">Ignoring line comments and empty lines</a></a></li>
<li><a href="#comments-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-comments-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#comments" title="Permalink to this headline">Comments</a></a></li>
</ul></li>
<li><a href="#dealing-with-unicode-data-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-dealing-with-unicode-data-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#dealing-with-unicode-data" title="Permalink to this headline">Dealing with Unicode data</a></a></li>
<li><a href="#index-columns-and-trailing-delimiters-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-index-columns-and-trailing-delimiters-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#index-columns-and-trailing-delimiters" title="Permalink to this headline">Index columns and trailing delimiters</a></a></li>
<li><a href="#date-handling-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-date-handling-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#date-handling" title="Permalink to this headline">Date Handling</a></a>
<ul>
<li><a href="#specifying-date-columns-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-specifying-date-columns-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#specifying-date-columns" title="Permalink to this headline">Specifying date columns</a></a></li>
<li><a href="#date-parsing-functions-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-date-parsing-functions-permalink-to-this-headline">Date parsing functions[](<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#date-parsing-functions">https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#date-parsing-functions</a> &ldquo;Permalink to this headline&rdquo;)</a></li>
<li><a href="#parsing-a-csv-with-mixed-timezones-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-parsing-a-csv-with-mixed-timezones-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#parsing-a-csv-with-mixed-timezones" title="Permalink to this headline">Parsing a CSV with mixed timezones</a></a></li>
<li><a href="#inferring-datetime-format-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-inferring-datetime-format-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#inferring-datetime-format" title="Permalink to this headline">Inferring datetime format</a></a></li>
<li><a href="#international-date-formats-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-international-date-formats-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#international-date-formats" title="Permalink to this headline">International date formats</a></a></li>
</ul></li>
<li><a href="#specifying-method-for-floating-point-conversion-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-specifying-method-for-floating-point-conversion-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#specifying-method-for-floating-point-conversion" title="Permalink to this headline">Specifying method for floating-point conversion</a></a></li>
<li><a href="#thousand-separators-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-thousand-separators-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#thousand-separators" title="Permalink to this headline">Thousand separators</a></a></li>
<li><a href="#na-values-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-na-values-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#na-values" title="Permalink to this headline">NA values</a></a></li>
<li><a href="#infinity-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-infinity-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#infinity" title="Permalink to this headline">Infinity</a></a></li>
<li><a href="#returning-series-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-returning-series-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#returning-series" title="Permalink to this headline">Returning Series</a></a></li>
<li><a href="#boolean-values-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-boolean-values-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#boolean-values" title="Permalink to this headline">Boolean values</a></a></li>
<li><a href="#handling-bad-lines-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-handling-bad-lines-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#handling-bad-lines" title="Permalink to this headline">Handling “bad” lines</a></a></li>
<li><a href="#dialect-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-dialect-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#dialect" title="Permalink to this headline">Dialect</a></a></li>
<li><a href="#quoting-and-escape-characters-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-quoting-and-escape-characters-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#quoting-and-escape-characters" title="Permalink to this headline">Quoting and Escape Characters</a></a></li>
<li><a href="#files-with-fixed-width-columns-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-files-with-fixed-width-columns-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#files-with-fixed-width-columns" title="Permalink to this headline">Files with fixed width columns</a></a></li>
<li><a href="#indexes-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-indexes-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#indexes" title="Permalink to this headline">Indexes</a></a>
<ul>
<li><a href="#files-with-an-implicit-index-column-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-files-with-an-implicit-index-column-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#files-with-an-implicit-index-column" title="Permalink to this headline">Files with an “implicit” index column</a></a></li>
<li><a href="#reading-an-index-with-a-multiindex-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-reading-an-index-with-a-multiindex-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#reading-an-index-with-a-multiindex" title="Permalink to this headline">Reading an index with a  <code>MultiIndex</code></a></a></li>
<li><a href="#reading-columns-with-a-multiindex-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-reading-columns-with-a-multiindex-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#reading-columns-with-a-multiindex" title="Permalink to this headline">Reading columns with a  <code>MultiIndex</code></a></a></li>
</ul></li>
<li><a href="#automatically-sniffing-the-delimiter-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-automatically-sniffing-the-delimiter-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#automatically-sniffing-the-delimiter" title="Permalink to this headline">Automatically “sniffing” the delimiter</a></a></li>
<li><a href="#reading-multiple-files-to-create-a-single-dataframe-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-reading-multiple-files-to-create-a-single-dataframe-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#reading-multiple-files-to-create-a-single-dataframe" title="Permalink to this headline">Reading multiple files to create a single DataFrame</a></a></li>
<li><a href="#iterating-through-files-chunk-by-chunk-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-iterating-through-files-chunk-by-chunk-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#iterating-through-files-chunk-by-chunk" title="Permalink to this headline">Iterating through files chunk by chunk</a></a></li>
<li><a href="#specifying-the-parser-engine-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-specifying-the-parser-engine-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#specifying-the-parser-engine" title="Permalink to this headline">Specifying the parser engine</a></a></li>
<li><a href="#reading-remote-files-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-reading-remote-files-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#reading-remote-files" title="Permalink to this headline">Reading remote files</a></a></li>
<li><a href="#writing-out-data-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-writing-out-data-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#writing-out-data" title="Permalink to this headline">Writing out data</a></a>
<ul>
<li><a href="#writing-to-csv-format-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-writing-to-csv-format-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#writing-to-csv-format" title="Permalink to this headline">Writing to CSV format</a></a></li>
<li><a href="#writing-a-formatted-string-https-pandas-pydata-org-pandas-docs-stable-user-guide-io-html-writing-a-formatted-string-permalink-to-this-headline"><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#writing-a-formatted-string" title="Permalink to this headline">Writing a formatted string</a></a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>

  
</body>

</html>
